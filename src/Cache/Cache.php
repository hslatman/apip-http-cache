<?php
/**
 * Author: Herman Slatman
 * Date: 2019-05-07
 * Time: 19:57
 */

namespace App\Cache;

use FOS\HttpCache\EventListener\LogListener;
use FOS\HttpCache\SymfonyCache\CacheInvalidation;
use FOS\HttpCache\SymfonyCache\DebugListener;
use FOS\HttpCache\SymfonyCache\EventDispatchingHttpCache;
use FOS\HttpCache\SymfonyCache\PurgeListener;
use FOS\HttpCache\SymfonyCache\RefreshListener;
use Monolog\Handler\ErrorLogHandler;
use Monolog\Handler\StreamHandler;
use Monolog\Logger;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\HttpCache\HttpCache;
use Symfony\Component\HttpKernel\HttpCache\StoreInterface;
use Symfony\Component\HttpKernel\HttpCache\SurrogateInterface;
use Symfony\Component\HttpKernel\HttpKernelInterface;

// TODO: look into difference between the HttpCache Component and HttpCache from FrameworkBundle
// The FosCacheBundle uses the Component, so we're using that too, now. It also seems neater
// to use the Component. No reliance on the full framework.
#use Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache;

class Cache extends HttpCache implements CacheInvalidation
{
    use EventDispatchingHttpCache;

    public function __construct(HttpKernelInterface $kernel, StoreInterface $store, SurrogateInterface $surrogate = null, array $options = [])
    {
        parent::__construct($kernel, $store, $surrogate, $options);

        $this->addSubscriber(new PurgeListener()); // SEE: https://foshttpcache.readthedocs.io/en/latest/symfony-cache-configuration.html#purge
        $this->addSubscriber(new RefreshListener()); // SEE: https://foshttpcache.readthedocs.io/en/latest/symfony-cache-configuration.html#refresh

        // NOTE: injecting an error log here; we can't inject the default logger, yet. Haven't tested the log output yet.
        $logger = new Logger('http_cache');
        $handler = new ErrorLogHandler();
        $logger->pushHandler($handler);
        $this->addSubscriber(new LogListener($logger));

        // The DebugListener is used when testing caching functionality; it logs the presence of miss/fresh in the X-Symfony-Cache header
        if (isset($options['debug']) && $options['debug']) {
            $this->addSubscriber(new DebugListener());
        }

        // TODO: further customization? like handling tags?

    }

    /**
     * Made public to allow event listeners to do refresh operations.
     *
     * {@inheritDoc}
     */
    public function fetch(Request $request, $catch = false)
    {
        return parent::fetch($request, $catch);
    }

    public function lookup(Request $request, $catch = false)
    {
        // NOTE: copied this function to be able to make sure that we're using the cache
        return parent::lookup($request, $catch); // TODO: Change the autogenerated stub
    }

    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        // NOTE: The $token is not set yet :-(
        $token = $request->headers->get('X-Debug-Token');

        $response = parent::handle($request, $type, $catch);

        //$response->headers->set('X-Debug-Token', $token);

        return $response;
    }

}
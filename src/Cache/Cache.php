<?php
/**
 * Author: Herman Slatman
 * Date: 2019-05-07
 * Time: 19:57
 */

namespace App\Cache;

use FOS\HttpCache\SymfonyCache\CacheInvalidation;
use FOS\HttpCache\SymfonyCache\EventDispatchingHttpCache;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\HttpCache\HttpCache;
use Symfony\Component\HttpKernel\HttpCache\StoreInterface;
use Symfony\Component\HttpKernel\HttpCache\SurrogateInterface;
use Symfony\Component\HttpKernel\HttpKernelInterface;

// TODO: look into difference between the HttpCache Component and HttpCache from FrameworkBundle
// The FosCacheBundle uses the Component, so we're using that too, now. It also seems neater
// to use the Component. No reliance on the full framework.
#use Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache;

class Cache extends HttpCache implements CacheInvalidation
{
    use EventDispatchingHttpCache;

    public function __construct(HttpKernelInterface $kernel, StoreInterface $store, SurrogateInterface $surrogate = null, array $options = [])
    {
        parent::__construct($kernel, $store, $surrogate, $options);
    }

    /**
     * Made public to allow event listeners to do refresh operations.
     *
     * {@inheritDoc}
     */
    public function fetch(Request $request, $catch = false)
    {
        return parent::fetch($request, $catch);
    }

    public function lookup(Request $request, $catch = false)
    {
        // NOTE: copied this function to be able to make sure that we're using the cache
        return parent::lookup($request, $catch); // TODO: Change the autogenerated stub
    }

}